# 缓存穿透
- 定义：
  - 存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时， 发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。此时，应用也无法从数据库中读取数据再写入缓存，来服务后续请求，这样一来，缓存也就成了“摆设”，如果应 用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力
- 产生原因
  - 业务层误操作:缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据; 
  - 恶意攻击:专门访问数据库中没有的数据。
- 解决方案
  - 1、缓存空值或缺省值
    - 如果一个查询数据为空(不管数据是否存在)，都对该空结果进行缓存，其过期时间会设置非常短。
    - 一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。
    - 方案-》缺陷
      - 空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间(如果是攻击，问题更严重)，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。 
      - 缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。 这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。
  - 2、布隆过滤器
    - 使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力
    - 原理
      - 布隆过滤器由一个初始值都为0的bit数组和N个哈希函数组成
      - 使用N个哈希函数，分别计算数据的哈希值，得到N个哈希值
      - 把N个哈希值对bit数组的长度取模，得到每个哈希值在数组中的对应位置
      - 把对应位置的bit位设置为1，这样就完成了在布隆过滤器中标记数据的操作
      - 查询某个数时，执行以上的计算过程 ，先得到这个数据在bit数组中对应的N个位置，然后查询bit数组中N个位置上的bit值，只要这N个bit值有一个不为1，就表明该数据不存在或者没有做过标记
      - 布隆过滤器的判断：存在->可能存在，不存在->一定不存在
      - https://www.jasondavies.com/bloomfilter/
    - 方案-》缺陷
      - 布隆过滤器会有误判:由于采用固定bit的数组，使用多个哈希函数映射到多个bit上，有可能会导致两个不同的值都映射到相同的一组bit上。虽然有误判，但对于业务没有影响，无非就是还存在一些穿透而已，但整体上已经过滤了大多数无效穿透请求。
      - 当数组过大时，查询效率不高：因为布隆过滤器的判断方式是根据多次hash值判断的，当数组过大，那么hash值的跨度可能就越大，跨度大就是不连续，那么CPU的缓存命中率就会变低，就会影响查询效率。
      - 布隆过滤器不能删除元素：因为不同的数据可能会计算出相同的hash值，因此我们如果要删除某个元素，可能也会影响其他的元素的判断。在这个限制条件下，当数据量大的时候，就会导致很多的垃圾数据。并且数据量越大，误判率也就会越高。只能重建！！！
      - 布隆过滤器误判率和空间使用的计算:误判本质是因为哈希冲突，降低误判的方法是增加 哈希函数 + 扩大整个bit数组的长度，但增加哈希函数意味着影响性能，扩大数组长度意味着 空间占用变大，所以使用布隆过滤器，需要在误判率和性能、空间作一个平衡，具体的误判率是有一个计算公式可以推导出来的(比较复杂)。但我们在使用开源的布隆过滤器时比较简单，通常会提供2个参数:预估存入的数据量大小、要求的误判率，输入这些参数后，布隆过滤器会有自动计算出最佳的哈希函数数量和数组占用的空间大小，直接使用即可。 
      - 布隆过滤器可以放在缓存和数据库的最前面:把Redis当作布隆过滤器时(4.0提供了布隆过滤器模块，4.0以下需要引入第三方库)，当用户产生业务数据写入缓存和数据库后，同时也写入布隆过滤器，之后当用户访问自己的业务数据时，先检查布隆过滤器，如果过滤器不存在，就不需要查询缓存和数据库了，可以同时降低缓存和数据库的压力。
      - Redis实现的布隆过滤器bigkey问题:Redis布隆过滤器是使用String类型实现的，存储的方式是一个bigkey，建议使用时单独部署一个实例，专门存放布隆过滤器的数据，不要和业务数据混用，否则在集群环境下，数据迁移时会导致Redis阻塞问题。
  - 3、请求入口的前端进行请求检测
    - 在请求入口前端，对业务系统接收到的请求进行合法性检测，把恶意的请求（比如请求参数不合理、请求参数是非法值、请求字段不存在）直接过滤掉，不让他们访问后端缓存和数据库
  - 4、进行实时监控
    - 对于redis缓存中命中率急速下降时，迅速排查访问对象和访问数据，将其设置为黑名单。
  - 5、规范数据库的数据删除操作，避免误删
  - 6、是否可以采用服务熔断、服务降级、请求限流的方法来应对缓存穿透问题?
    - 区分场景来看
      - 如果缓存穿透的原因是恶意攻击，攻击者故意访问数据库中不存在的数据。这种情况可以先 使用服务熔断、服务降级、请求限流的方式，对缓存和数据库层增加保护，防止大量恶意请 求把缓存和数据库压垮。在这期间可以对攻击者进行防护，例如封禁IP等操作。
      - 如果缓存穿透的原因是，业务层误操作把数据从缓存和数据库都删除了，如果误删除的数据很少，不会导致大量请求压到数据库的情况，那么快速恢复误删的数据就好了，不需要使用服务熔断、服务降级、请求限流。如果误操作删除的数据范围比较广，导致大量请求压到数据库层，此时使用服务熔断、服务降级、请求限流的方法来应对是有帮助的，使用这些方法先把缓存和数据库保护起来，然后使用备份库快速恢复数据，在数据恢复期间，这些保护方法可以为数据库恢复提供保障。
      - 对于一个刚上线的新业务模块，如果还没有用户在这个模块内产生业务数据，当用户需要查询这个业务模块自己的数据时，由于缓存和数据库都没有这个用户的数据，此时也会产生缓存穿透，但这种场景不像误删数据和恶意攻击那样，而是属于正常的用户行为。这种场景采用服务熔断、服务降级、请求限流的方式就没有任何意义了，反而会影响正常用户的访问。这种场景只能使用缓存回种空值、布隆过滤器来解决。
    - 可见，服务熔断、服务降级、请求限流的作用是，当系统内部发生故障或潜在问题时，为了防止系统内部的问题进一步恶化，所以会采用这些方式对系统增加保护，待系统内部故障恢复后，可以依旧继续对外提供服务，这些方法属于服务治理的范畴，在任何可能导致系统故障的场景下，都可以选择性配合使用。
- 布隆过滤器增强版
  - 为了解决上面布隆过滤器的问题,出现了一个增强版的布隆过滤器(Counting Bloom Filter),这个过滤器的思路是将布隆过滤器的bitmap更换成数组,当数组某位置被映射一次时就+1,当删除时就-1,这样就避免了普通布隆过滤器删除数据后需要重新计算其余数据包Hash的问题,但是依旧没法避免误判。 
- 布谷鸟过滤器
  - 论文《Cuckoo Filter：Better Than Bloom》
  - 布谷鸟过滤器可以说是一个增强版的布隆过滤器，可以删除元素，查询效率更高，空间利用率更高。
  - 优点
    - 布谷鸟过滤器支持删除元素，布隆过滤器不支持 
    - 高负载因子场景下，布谷鸟过滤器查询效率更高 
    - 对于存储数据量较大且期望误判率较低 (小于 3%) 的场景下，布谷鸟过滤器存储空间开销更低 
    - 布谷鸟过滤器比布隆过滤器更容易实现
  - 缺点
    - 布谷鸟过滤器采用一种备用候选桶的方案，候选桶与首选桶可以通过 位置 + 值指纹的哈希 通过 异或计算 得出，这种对应关系要求桶的大小必须是 2 的指数倍数 (如 4, 8, 16, 32...)
    - 布隆过滤器插入时计算好哈希直接写入位即可，而布谷鸟过滤器在计算后可能会出现对应位置上已经存储了指纹，这时就需要将已存储的值踢出到候选桶，碰撞概率和插入耗时随着表元素增多而增大，因此其插入性能低于布隆过滤器 
    - 布隆过滤器插入重复元素时没有影响 (可以重复插入)，而布谷鸟过滤器对已存在的值会执行 踢出 操作，因此重复元素的插入存在上限 
    - 布谷鸟过滤器的删除并不完美，删除操作在相同哈希值仅被插入一次时是完美的，如果元素没有插入就进行删除，可能会出现误删除 (删除了相同哈希值的其他元素)， 如果元素插入了多次，但是每次删除操作只删除一个值，那么就需要知道元素插入了多少次才能彻底删除，或者循环删除直到失败为止 作者：清澄秋爽 https://www.bilibili.com/read/cv25048363/ 出处：bilibili
          