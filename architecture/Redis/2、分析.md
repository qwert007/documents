# 为什么使用redis?
从以下两个维度去思考，
- 高性能；在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样， 后面的请求就去缓存中读取，使得请求能够迅速响应。
- 高并发；在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis 做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

# Redis的过期策略有哪些?
- 有两种过期策略，定期删除+惰性删除
  - 定期删除
    - Redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果有过期时间就删除
    - 注意：
      - 定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面过期的key
      - 由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去检查和删除
      - 为什么要随机呢？假如redis存储了几十万的key，每隔100ms就遍历所有的设置了过期时间的key的话，就会给CPU带来很大的负载
      - 为什么不用单个key的到期就删除策略呢?定时删除，需要用一个定时器来负责监视key，过期则自动删除，虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间用在处理请求而不是删除key，因此没有采用这种策略
  - 惰性删除
    - 指的是当我们查询key的时候才对key进行检查，如果已经达到过期时间则删除，显然，它有一个缺点就是如果这些过期的key没有被访问，那么他就是一直无法被删除，而且一直占用内存
    - 为啥要惰性删除呢？定期删除可能会导致很多过期的key到了时间并没有被删除，这时就使用到惰性删除作为一个补充手段。
    - 懒惰删除默认是在主线程删除，并释放key内存的。但在4.0+版本又做了优化，释放key内存可以放到了异步线程中去做了（lazy-free），目的是可以减少主线程释放内存的耗时，提升主线程处理性能。 也就是说4.0之前，懒惰删除就是同步删除。4.0优化后，懒惰删除就是同步删除全局hash表的键值对+子线程程执行释放内存，但需要开启lazy-free配置才生效。
    - 有百万的key在一段时间过期，比如2个小时，如果应用订阅了key失效事件，在两个小时内，这些通知事件都会发出来吗？不一定，如果没有请求到过期的key，那么这些过期key会是定时任务做清理，有可能key已经到了过期时间了，但还没有被扫描到，自然也就不会立即被清理掉，可能存在一定延迟。
- 定期删除+惰性删除存在的问题
  - 如果某个key过去后，定期删除没有删除成功，然后也没有再次去请求key，也就是说惰性删除也没有生效。这时，如果大量过期的key堆积在内存中，redis的内存会越来越大，导致redis的内存耗尽。那么就应该采取内存淘汰机制
  
- master节点是以上这种情况，如果此时读取的是slave呢，slave针对这个过期key会怎么处理呢？
  - slave 也会记录 key 的过期时间，如果 key 已过期，在 slave 上查询到这个 key 时，slave 给客户端返回 null，但不删除这个 key。
  - slave 什么时候删除呢？master 删除过期 key 时，会发 DEL 给 slave，此时 slave 才会删除这个 key。
- 如果有一批 key 已经过期，但还未被Redis清理掉，问：此时生成的RDB会包含这些过期key吗？Redis加载这个RDB，会包含这些过期key吗？还是直接过滤？
  - Redis 5.0 以下版本，规则如下：
    - Redis生成RDB，默认会过滤已过期的key，这么做的目的是，缩小RDB的体积。
    - Redis加载RDB，主库和从库逻辑不一样：主库加载 RDB，会自动忽略加载已过期的key。从库加载RDB，不忽略，RDB有啥就加载啥。
  - Redis 5.0 以上版本，做了改动，规则如下：
    - 加载RDB的逻辑不变，但生成RDB的逻辑变了。
    - 5.0 以上版本，Redis 生成 RDB 时不忽略过期key了。（具体可参见 rdb.c -> rdbSaveKeyValuePair方法）。为什么改成这样呢？
      - Redis 4.0对主从同步进一步做了优化。主从切换后，旧主库可以和新主库直接增量同步，而不用走全量同步，避免了全量同步的成本。
      - 但是，存在这样一种场景，会导致这个过程有问题：主库大量key已过期，但还未清理，这时添加一个从库上来，此时主库RDB会过滤过期key，从库走全量同步拿到的key就不是最全的。此时，发起了主从切换，因为4.0对主从同步做了优化，允许增量同步数据，所以，旧主库此时作为从库开始增量同步数据。
      - 但是，此时从库有大量key未被清理，而主库加载RDB时也没有拿到这些过期key，所以没办法发DEL给从库，这时从库的这些key就遗留在内存中了，造成了内存泄露。所以Redis针对这个问题，在生成RDB时，只能把全量数据写进去，不能做任何过滤逻辑。
# 主从库数据不一致的原因是否还有exipre命令同步延迟？expire 命令在主库、从库上执行时，会存在过期时间不一致的情况吗？
  会出现的，expire执行时，是以当前机器的时钟为基准，开始计算过期时间的。可能存在这样的场景：slave因为某种原因卡住了一会，那master发给slave的expire命令，在slave上执行时计算的过期时间就会晚一些。不过这种情况其实还好。 如果在master上查这个key，那master就会马上清理它，然后给slave发DEL也让slave清理掉。 最怕的是，slave时钟走得快，slave很多key本来没过期，却被认为过期了，这就比较麻烦了。如果此时主从切换，那新master会开始清理过期key，严重会引发缓存雪崩。
  
# Reids内存淘汰策略有哪些？
Redis共提供了8中缓存淘汰策略，其中 volatile-lfu 和 allkeys-lfu 是Redis 4.0版本新增的。
- 1、noeviction 不进行淘汰数据，一旦缓存被写满，再有请求进来，Redis就不再提供服务，而是直接返回错误。Redis用作缓存时，实际的数据集通常都是大于缓存容量的，总会有新的数据要写入缓存，这个策略本身不淘汰数据，也就不会腾出新的缓存空间。我们不把它用在Redis缓存中
- 2、volatile-ttl:在设置了过期时间的键值对中，移除即将过期的键值对。
- 3、volatile-random:在设置了过期时间的键值对中，随机移除某个键值对。
- 4、volatile-lru:在设置了过期时间的键值对中，移除最近最少使用(最近最久未使用)的键值对。
- 5、volatile-lfu:在设置了过期时间的键值对中，移除最近最不频繁使用的键值对, 或者移除最不经常使用的键值对
- 6、allkeys-random:在所有键值对中，随机移除某些key。 
- 7、allkeys-lru:在所有的键值对中，移除最近最少使用(最近最久未使用)的键值对。 
- 8、allkeys-lfu:在所有的键值对中，移除最近最不频繁使用的键值对, 或者移除最不经常使用的键值对
- 实践建议
  - 通常情况下推荐优先使用 allkeys-lru 策略。 这样可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。 如果你的业务数据中有明显的局部周期性流量(局部冷热数据区分明显)，建议使用 allkeys-lru 策略。
  - 如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys- random 策略，随机选择淘汰的数据就行。
  - 如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。

# Redis 中lru算法介绍一下
- Least Recently Used
- LRU 会把所有的数据组织成一个链表，链表的头和尾分表表示MRU端和LRU端，分表代表最近常使用的数据和最近不常使用的数据
- LRU算法再实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问是，需要在链表上把该数据移动到MRU端，如果有大量的数据被访问，就会带来很多链表的移动操作，会很耗时，进而会降低Redis缓存性能
- Redis对于LUR算法做了简化，以减轻数据淘汰对缓存性能的影响
  - Redis默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构RedisObject中的lru字段记录）
  - Redis在决定淘汰的数据时，第一次会随机选出N个数据，把他们作为一个候选集合
  - Redis会比较这N个数据的lru字段，把lru字段值小的数据重缓存中淘汰出去
  - Redis提供了一个配置参数maxmemory-samples，就是Redis选出的数据个数N
  - 当需要淘汰数据时，Redis需要挑选数据进入第一次淘汰时创建的候选集合，挑选的标准是能进入候选集合的数据的lru字段值必须小于候选集合中最小的lru值

# 一个系统引入缓存时，如何保证缓存和后端数据库的一致性问题
- Cache Aside策略，只读缓存模式，读操作命中缓存直接返回，否则从后端数据库加载到缓存再返回，写操作直接更新数据库，然后删除缓存。
  - 优点 一切以后端数据库为准，可以保证缓存和数据库的一致性
  - 缺点 写操作会让缓存失效，再次读取需要从数据库中加载
- Read/Write Throught策略，应用层读写操作只需要操作缓存，不需要关心后端数据库。应用层操作缓存时，缓存层会自动从数据库中加载或写回到数据库中
  - 优点 对于应用层的使用非常友好，只需要操作缓存即可
  - 缺点 缓存层需要支持和后端数据库的联动
- Write Back策略，即为读写缓存模式+异步写回模式

# redis 都有哪些数据类型?分别在哪些场景下使用比 较合适?
- 主要的数据类型
  - string 
  - hash 
  - list 
  - set 无序集合，自动去重，可以基于 set 玩儿交集、并集、差集的操作
  - sorted set 排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序

# Redis支持事务吗？
