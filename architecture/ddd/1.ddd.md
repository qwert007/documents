# DDD
## MVC设计存在的问题
1. MVC模式仅仅反应了软件层面的架构，它不包含业务语言，无法使用该设计直接和业务对话。
2. MVC模式天然切割了数据和行为，然后用数据库实现数据，用服务实现行为，容易造成需求的首尾分离。
3. 缺乏明确的边界划分，至少在顶层设计层面没有边界划分的规范要求，更多地是靠技术负责人根据经验进行划分，大规模团队协作容易出现职责不清晰、分工不明确。

## 领域驱动优势
1. 通过模型直接反映软件实现的结构。
2. 以模型为基础形成团队的统一语言。
3. 把模型作为精粹的知识，用于传递。

## DDD价值
- 统一语言： 团队（业务方、产品、设计、技术等）在一个限定的上下文中有意识地形成对事物统一的描述，从而形成统一的概念（模型）。统一语言用于需求文档、PRD文档、系分文档、代码以及日常沟通中，统一的概念和术语可以极大地提升沟通效率和工作效率。
- 面向业务建模： 领域模型和数据模型分离，业务复杂度和技术复杂度分离。DDD聚焦于领域模型，将技术实现细节从模型中剥离出来，能够更好地降低业务和技术的耦合度。
- 边界清晰的设计方法： 通过对需求的识别及分类，划分出领域、子域和限界上下文，进而指导团队成员分工协作，从而做到将复杂的问题分而治之地解决。
- 业务领域的知识沉淀： 通过模型与软件实现关联，统一语言与模型关联，反复论证和提炼模型，使得模型与业务的真实世界保持一致，从而促使业务知识通过模型得以传递和沉淀，
### DDD名词
- 实体（Entity）
  - 通过一个唯一标识字段来区分真实世界中的每一个个体的领域对象（实体 = 唯一身份标识 + 可变性）
  - 在实体的生命周期内，无论其如何变化，其仍旧是同一个实体。
    - 实体本身是有状态的；
    - 实体有严谨的生命周期；
    - 实体本身会体现出相应的业务行为；
    - 业务行为会被实体属性/状态造成影响和改变。
- 值对象（ValueObject）
  - 代表的是真实世界中哪些一成不变、本质性的事物，这样的领域对象叫做“值对象”。当一个对象用于对事物进行描述而没有唯一标识时，它被称为值对象。（值对象 = 值 + 对象 = 将一个值用对象的方式进行表述， 来表达一个具体的固定不变的概念。 ）
  - 本身无状态，不可变，并且不分配具体的标识。
  - 本身无生命周期，也不会产生独立行为
  - 在实践中，需要保证值对象创建后就不能被修改，即不允许外部载修改其属性。
- 实体与值对象区别
  - 可变性是实体的特点，不变性是值对象的本质。
- 聚合根(AggregateRoot)
  - 是一组相关对象的集合，作为一个整体被外界访问，聚合根就是这个聚合的根节点。
  - 领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。
  - 首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑
  - 其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。
  - 最后在聚合之间，它还是聚合对外的接口人，以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根ID关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。
#### 特点
- 聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。 一个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同
- 实体有 ID 标识，通过 ID 判断相等性，ID 在聚合内唯一即可。状态可变，它依附于聚合根，其生命周期由聚合根管理。 实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。 实体可以引用聚合内的聚合根、实体和值对象。
- 值对象无 ID，不可变，无生命周期，用完即扔。 值对象之间通过属性值判断相等性。 它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。 值对象尽量只引用值对象。

### 战略设计
- 战略设计是根据用户旅程分析，找出领域对象和聚合根，对实体和值对象进行聚类组成聚合，划分限界上下文，建立领域模型的过程。
- 战略设计采用的方法是事件风暴，包括：产品愿景、场景分析、领域建模和微服务拆分等几个主要过程。
  - 产品愿景是对产品顶层价值设计，对产品目标用户、核心价值、差异化竞争点等信息达成一致，避免产品偏离方向。产品愿景分析对于初创系统明确系统建设重点，统一团队建设目标和建立通用语言是很有价值的。
  - 事件风暴时，所有参与者针对每一个要点，在贴纸上写出自己的意见，贴到白板上。事件风暴主持者会对每个贴纸，讨论并对发散的意见进行收敛和统一，形成产品愿景图。
  - 场景分析是从用户视角出发，探索业务领域中的典型场景，产出领域中需要支撑的场景分类、用例操作以及不同子域之间的依赖关系，用以支撑领域建模。
  - 领域建模是通过对业务和问题域进行分析，建立领域模型。向上通过限界上下文指导微服务边界设计，向下通过聚合指导实体对象设计。
    - 领域建模是一个收敛的过程，分三步：
      - 第一步找出领域实体和值对象等领域对象；（根据场景分析，分析并找出发起或产生这些命令或领域事件的实体和值对象，将与实体或值对象有关的命令和事件聚集到实体。）
      - 第二步找出聚合根，根据实体、值对象与聚合根的依赖关系，建立聚合；（定义聚合前，先找出聚合根，然后找出与聚合根紧密依赖的实体和值对象。）
      - 第三步根据业务及语义边界等因素，定义限界上下文。
  - 微服务拆分
      - 理论上一个限界上下文就可以设计为一个微服务，但还需要综合考虑多种外部因素，比如：职责单一性、敏态与稳态业务分离、非功能性需求（如弹性伸缩、版本发布频率和安全等要求）、软件包大小、团队沟通效率和技术异构等非业务要素。

- 战略设计阶段建议参与人员：领域专家、业务需求方、产品经理、架构师、项目经理、开发经理和测试经理。

### 战术设计
- 战术设计是根据领域模型进行微服务设计的过程。这个阶段主要梳理微服务内的领域对象，梳理领域对象之间的关系，确定它们在代码模型和分层架构中的位置，建立领域模型与微服务模型的映射关系，以及服务之间的依赖关系。
- 战术设计阶段建议参与人员：领域专家、产品经理、架构师、项目经理、开发经理和测试经理等。
- 战术设计包括以下两个阶段：分析微服务领域对象和设计微服务代码结构。
    - 分析微服务领域对象：在事件风暴基础上，我们进一步细化领域对象以及它们的关系，补充事件风暴可能遗漏的业务和技术细节。（分析微服务内应该有哪些服务？服务的分层？应用服务由哪些服务组合和编排完成？领域服务包括哪些实体和实体方法？哪个实体是聚合根？实体有哪些属性和方法？哪些对象应该设计为值对象等）
        - 服务的识别和设计
            - 事件风暴的命令是外部的一些操作和业务行为，也是微服务对外提供的能力。它往往与微服务的应用服务或者领域服务对应。我们可以将命令作为服务识别和设计的起点。具体步骤如下：
                - 根据命令设计应用服务，确定应用服务的功能，服务集合，组合和编排方式。服务集合中的服务包括领域服务或其它微服务的应用服务。
                - 根据应用服务功能要求设计领域服务，定义领域服务。这里需要注意：应用服务可能是由多个聚合的领域服务组合而成的。
                - 根据领域服务的功能，确定领域服务内的实体以及功能。
                - 设计实体基本属性和方法。
                - 领域事件的异步化处理
            - 聚合中的对象、微服务内的对象清单（在确定各领域对象的属性后，我们就可以设计各领域对象在代码模型中的代码对象（包括代码对象的包名、类名和方法名），建立领域对象与代码对象的一一映射关系了。根据这种映射关系，相关人员可快速定位到业务逻辑所在的代码位置。）
    - 设计微服务代码结构
        - 应用层代码结构
        - 领域层代码结构
        - 详细设计
        - 开发&测试

### 六边形架构、整洁架构区别、CQRS

#### 六边形架构
端口-适配器

六边形架构将系统分为内部（内部六边形）和外部，内部代表了应用的业务逻辑，外部代表应用的驱动逻辑、基础设施或其他应用。内部通过端口和外部系统通信，端口代表了一定协议，以API呈现。一个端口可能对应多个外部系统，不同的外部系统需要使用不同的适配器，适配器负责对协议进行转换。这样就使得应用程序能够以一致的方式被用户、程序、自动化测试、批处理脚本所驱动，并且，可以在与实际运行的设备和数据库相隔离的情况下开发和测试。

六边形架构的核心理念是：应用是通过端口与外部进行交互的。

#### CQRS
CQRS本身只是一个读写分离的架构思想，全称是：Command Query Responsibility Segregation，即命令查询职责分离，表示在架构层面，将一个系统分为写入（命令）和查询两部分。一个命令表示一种意图，表示命令系统做什么修改，命令的执行结果通常不需要返回；一个查询表示向系统查询数据并返回。

CQRS架构中，另外一个重要的概念就是事件，事件表示命令操作领域中的聚合根，然后聚合根的状态发生变化后产生的事件。

CQRS其实就是读写分离，主要解决DDD的复杂查询问题。一般是写库和读库分离，但是实效性不容易保证。其实你也可以在同一个库，用领域或者应用查询服务来完成复杂查询的。

由于CQRS架构的一致性模型为**最终一致性**，所以，你的系统要**接受查询到的数据可能不是最新的**，而是有几个毫秒的延迟。

#### 整洁架构

又名“洋葱架构”（看图就懂），体现了分层思想。
同心圆代表应用软件的不同部分，由内到外依次是

- 领域模型
- 领域服务
- 应用服务

容易变化的内容 比如用户接口和基础设施。 该架构最主要原则：依赖原则，它定义了各层依赖关系，越往内依赖越低，代码级别越高，能力越核心。外圈代码依赖只能指向内圈，内圈无需知道外圈任何情况。