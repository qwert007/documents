# 内核架构
## 强内核/单内核/宏内核
- 强内核，又称宏内核或单内核，是操作系统内核架构的一种，简单理解，就是把所有要用到的东西都放到了内核里，比如最基本的进程、线程管理、内存管理、文件系统、驱动、网络协议等等。因为所有的模块都是在内核里，那优点就是处理效率高，但随着内核增大，管理起来也越不方便，而且只要其中一个模块出现问题，就会导致整个内核崩溃，系统的稳定性就差一些。
### 代表产品
- 宏内核的代表是Linux，可能有人会说微内核看起来更好，为什么 Linux不用微内核。Linux第一版用的是宏内核，之后也一直沿用下来，在Linus看来没有必要去重写Linux内核
- 一是这种结构实现起来是比较简单的，避免了划分模块、设计消息结构等麻烦
- 二是Linux没有研发时间上的限制，也不受市场的压力，其实就是有的是时间把单内核写好
- 三是Linux其实在单内核内核实现了充分的模块化，也就相当于吸收了微内核的优点，扩展及管理起来并没有那么困难
- 四是Linus认为了为增加可维护性而牺牲处理效率是不值得的
- Linux是一个单内核，也就是说，Linux内核运行在单独的内核地址空间。不过，Linux汲取了微内核的精华：其引以为豪的是模块化设计、抢占式内核、支持内核线程以及动态装载内核模块的能力。不仅如此，Linux还避其微内核设计上性能损失的缺陷，让所有事情都运行在内核态，直接调用函数，无需消息传递。至今，Linux是模块化的、多线程的以及内核本身可调度的操作系统。实用主义再次占了上风。
## 微内核
- 微内核是指将内核模块化设计，大部分内核都作为单独的进程，相互之间通过消息传递进行通信。微内核的功能类似于一个消息的转发站，优点是有助于内核功能的扩展和模块间的隔离，单个模块的bug不影响整个内核，只要杀掉出问题的进程就可以了，内核稳定性高，缺点就是进程间通信肯定会影响内核的效率。
- 微内核架构（Microkernel Architecture），也被成为插件化架构（Plug-in Architecture）,是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品（原文为product-based，指存在多个版本，需要下载安装才能使用，与web-based想对应）的应用。
### 基本架构
- 核心系统（core system）：核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；
- 插件模块（plug-in modules）：插件模块负责实现具体的业务逻辑
- 优点
  - 微内核架构的本质就是将变化封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。
### 设计关键点
- 插件管理
  - 插件系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件，常见的实现方法是插件注册表机制。
  - 核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载等）
- 插件连接
  - 插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。
  - 常见的连接机制有OSGi（Eclipse使用）、消息模式、依赖注入（Spring使用），甚至使用分布式的协议都是可以的，比如RPC或者HTTP Web的方式。
- 插件通信
  - 通信必须经过核心系统，因此核心系统需要提供插件通信机制。

### OSGi架构
- OSGi的全称是Open Services Gateway intiative,本身其实是指OSGi Alliance
- OSGi是一个插件化的标准，而不是一个可运行的框架，Eclipse采用的OSGi框架为Equinox，类似的实现还有Apache的Felix、Spring的Spring DM。
#### OSGi框架的逻辑架构
- 模块层（module层）：模块层实现插件管理功能。
  - OSGi中，插件被称为Bundle，每个Bundle是一个java的jar文件，每个Bundle里面都包含一个元数据文件MANIFEST.MF，这个文件包含了Bundle的基本信息。例如，Bundle的名称、描述、开发商、classpath，以及需要导入的包和输出的包等，OSGi核心系统会将这些信息加载到系统中用于后续使用。
- 声明周期层：声明周期层实现插件连接功能，提供了执行时模块管理、模块对底层OSGi框架的访问。
  - 生命周期层精确的定义了Bundle生命周期的操作（安装、更新、启动、停止、卸载），Bundle必须按照规范实现各个操作
- 服务层（service层）：服务层实现插件通信的功能
  - OSGi提供了一个服务注册的功能，用于各个插件将自己提供的服务注册到OSGi核心的注册中心，如果某个服务想用其他服务，则直接在服务注册中心搜索可用中心即可。
### 规则引擎架构
- 规则引擎从结构上来看也属于微内核架构的一种具体体现，其中执行引擎可以看做是微内核，执行引擎解析配置好的业务流，执行其中的条件和规则，通过这种方式来支持业务的灵活多变。
- 规则引擎基本架构
  - 业务流程
    - 开发人员将业务功能分解提炼为多个规则，将规则保存在规则库中 
    - 业务人员根据业务需要，通过将规则排列组合，配置成业务流程，保存在业务库中 
    - 规则引擎执行业务流程，实现业务功能
  - 落地实现
    - 插件管理：
      - 规则引擎中的规则就是微内核架构中的插件，引擎就是微内核架构的内核。规则可以被引擎加载和执行。规则引擎架构中，规则一般保存在规则库中，使用数据库来存储。
    - 插件连接
      - 业务人员需要基于规则语言来编写规则文件，然后有规则引擎加载执行规则文件来直线业务功能。因为规则引擎的插件连接实现机制，其实就是规则语言。
    - 插件通信
      - 单个规则并不需要依赖其他规则，因此规则之间没有主动的通信，规则只需要输出数据或者事件。
  
### 代表产品
- Windows
- Macos
- 以上两者在其新近版本中不让任何微内核服务器运行在用户空间，这违背了微内核设计的初衷。
